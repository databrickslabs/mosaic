import subprocess

from pyspark.sql import SparkSession

from mosaic.config import config

from .enable import refresh_context
from .fuse import SetupMgr

__all__ = [
    "setup_gdal",
    "enable_gdal",
    "update_checkpoint_path",
    "set_checkpoint_on",
    "set_checkpoint_off",
    "has_context",
    "is_use_checkpoint",
    "get_checkpoint_path",
    "reset_checkpoint",
    "get_checkpoint_path_default",
]


def setup_gdal(
    to_fuse_dir: str = "/Workspace/Shared/geospatial/mosaic/gdal/jammy/0.4.2",
    script_out_name: str = "mosaic-gdal-init.sh",
    jni_so_copy: bool = False,
    test_mode: bool = False,
) -> bool:
    """
    Prepare GDAL init script and shared objects required for GDAL to run on spark.
    This function will generate the init script that will install GDAL on each worker node.
    After the setup_gdal is run, the init script must be added to the cluster; also,
    a cluster restart is required.

    Notes:
      (a) This is close in behavior to Mosaic < 0.4 series (prior to DBR 13),
          now using jammy default (3.4.1)
      (b) `to_fuse_dir` can be one of `/Volumes/..`, `/Workspace/..`, `/dbfs/..`;
           however, you should use `setup_fuse_install()` for Volume based installs

    Parameters
    ----------
    to_fuse_dir : str
            Path to write out the init script for GDAL installation;
            default is '/Workspace/Shared/geospatial/mosaic/gdal/jammy/0.4.2'.
    script_out_name : str
            name of the script to be written;
            default is 'mosaic-gdal-init.sh'.
    jni_so_copy : bool
            if True, copy shared object to fuse dir and config script to use;
            default is False
    test_mode : bool
            Only for unit tests.

    Returns
    -------
    True unless resources fail to download.
    """
    setup_mgr = SetupMgr(
        to_fuse_dir, script_out_name=script_out_name, jni_so_copy=jni_so_copy
    )
    return setup_mgr.configure(test_mode=test_mode)


def enable_gdal(spark: SparkSession, with_checkpoint_path: str = None) -> None:
    """
    Enable GDAL at runtime on a cluster with GDAL installed using init script,
    e.g.  generated by setup_gdal() or setup_fuse_install() call.

    Parameters
    ----------
    spark : pyspark.sql.SparkSession
            The active SparkSession.
    with_checkpoint_path : str
            Optional, enable checkpointing;
            default is None.

    Returns
    -------
    """
    try:
        if with_checkpoint_path is not None:
            spark.conf.set("spark.databricks.labs.mosaic.raster.use.checkpoint", "true")
            spark.conf.set(
                "spark.databricks.labs.mosaic.raster.checkpoint", with_checkpoint_path
            )
            refresh_context()
            config.mosaic_context.jEnableGDAL(
                spark, with_checkpoint_path=with_checkpoint_path
            )
        else:
            config.mosaic_context.jEnableGDAL(spark)

        print("GDAL enabled.\n")
        if with_checkpoint_path:
            print(
                f"checkpoint path '{with_checkpoint_path}' configured for this session."
            )
        result = subprocess.run(["gdalinfo", "--version"], stdout=subprocess.PIPE)
        print(result.stdout.decode() + "\n")
    except Exception as e:
        print(
            "GDAL not enabled. Mosaic with GDAL requires that GDAL be installed on the cluster.\n"
        )
        print(
            "You can run `setup_gdal()` or `setup_fuse_install()` to generate the init script for GDAL install.\n"
        )
        print(
            "After the init script is generated, you need to add it to your cluster and restart.\n"
        )
        print("Error: " + str(e))


def update_checkpoint_path(spark: SparkSession, path: str):
    """
    Change the checkpoint location; does not adjust checkpoint on/off (stays as-is).
    :param spark: session to use.
    :param path: new path.
    """
    spark.conf.set("spark.databricks.labs.mosaic.raster.checkpoint", path)
    refresh_context()
    config.mosaic_context.jUpdateCheckpointPath(spark, path)


def set_checkpoint_off(spark: SparkSession):
    """
    Turn off checkpointing.
    :param spark: session to use.
    """
    spark.conf.set("spark.databricks.labs.mosaic.raster.use.checkpoint", "false")
    refresh_context()
    config.mosaic_context.jSetCheckpointOff(spark)


def set_checkpoint_on(spark: SparkSession):
    """
    Turn on checkpointing, will use the configured path.
    :param spark: session to use.
    """
    spark.conf.set("spark.databricks.labs.mosaic.raster.use.checkpoint", "true")
    refresh_context()
    config.mosaic_context.jSetCheckpointOn(spark)


def reset_checkpoint(spark: SparkSession):
    """
    Go back to defaults.
    - spark conf unset for use checkpoint (off)
    - spark conf unset for checkpoint path
    :param spark: session to use.
    """
    spark.conf.set("spark.databricks.labs.mosaic.raster.use.checkpoint", "false")
    spark.conf.set(
        "spark.databricks.labs.mosaic.raster.checkpoint", get_checkpoint_path_default()
    )
    refresh_context()
    config.mosaic_context.jResetCheckpoint(spark)


#################################################################
# GETTERS
#################################################################


def has_context() -> bool:
    """
    This is run on the driver, assumes enable.py already invoked.
    :return: True if the mosaic context has been initialized;
             otherwise False.
    """
    try:
        return config.mosaic_context.has_context()
    except Exception as e:
        return False


def is_use_checkpoint() -> bool:
    """
    This is run on the driver, assumes enable.py already invoked.
    :return: checkpoint on/off; otherwise exception.
    """
    return config.mosaic_context.is_use_checkpoint()


def get_checkpoint_path() -> str:
    """
    This is run on the driver, assumes enable.py already invoked.
    :return: checkpoint path or exception.
    """
    return config.mosaic_context.get_checkpoint_path()


def get_checkpoint_path_default() -> str:
    """
    This is run on the driver, assumes enable.py already invoked.
    :return: default checkpoint path.
    """
    return config.mosaic_context.get_checkpoint_path_default()
